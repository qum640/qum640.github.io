
<!DOCTYPE html>
<html>
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="utf-8">
  
  <title>存储管理 | Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="存储管理 存储管理是操作系统的重要组成部分，负责管理计算机系统的内存储器 由于任何程序和数据都必须占用内存空间才能得以执行和处理，因此存储管理的优劣直接影响系统的性能  存储器 存储器的层次  目前计算机系统采用层次结构的存储系统。         内存储器用于保护进程运行时的数据和程序 由于内存储器的访问速度远低于CPU执行指令的速度，为缓和这一矛盾，引入了寄存器和高速缓存。 为扩充内存储器的存">
<meta name="keywords" content="操作系统">
<meta property="og:type" content="article">
<meta property="og:title" content="存储管理">
<meta property="og:url" content="http://yoursite.com/2019/06/22/存储管理/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="存储管理 存储管理是操作系统的重要组成部分，负责管理计算机系统的内存储器 由于任何程序和数据都必须占用内存空间才能得以执行和处理，因此存储管理的优劣直接影响系统的性能  存储器 存储器的层次  目前计算机系统采用层次结构的存储系统。         内存储器用于保护进程运行时的数据和程序 由于内存储器的访问速度远低于CPU执行指令的速度，为缓和这一矛盾，引入了寄存器和高速缓存。 为扩充内存储器的存">
<meta property="og:locale" content="default">
<meta property="og:updated_time" content="2019-06-22T11:04:04.252Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="存储管理">
<meta name="twitter:description" content="存储管理 存储管理是操作系统的重要组成部分，负责管理计算机系统的内存储器 由于任何程序和数据都必须占用内存空间才能得以执行和处理，因此存储管理的优劣直接影响系统的性能  存储器 存储器的层次  目前计算机系统采用层次结构的存储系统。         内存储器用于保护进程运行时的数据和程序 由于内存储器的访问速度远低于CPU执行指令的速度，为缓和这一矛盾，引入了寄存器和高速缓存。 为扩充内存储器的存">
  
    <link rel="alternative" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  <link rel="stylesheet" href="/css/style.css">
  <!--[if lt IE 9]><script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7/html5shiv.min.js"></script><![endif]-->
  
</head></html>
<body>
<div id="container">
  <div id="wrap">
    <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Hexo</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//www.baidu.com/baidu" method="get" accept-charset="utf-8" class="search-form">
          <input type="search" name="word" maxlength="20" class="search-form-input" placeholder="Search">
          <input type="submit" value class="search-form-submit">
          <input name="tn" type="hidden" value="bds">
          <input name="cl" type="hidden" value="3">
          <input name="ct" type="hidden" value="2097152">
          <input type="hidden" name="si" value="yoursite.com">
        </form>
      </div>
    </div>
  </div>
</header>
    <div class="outer">
      <section id="main"><article id="post-存储管理" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/06/22/存储管理/" class="article-date">
  <time datetime="2019-06-22T10:00:22.965Z" itemprop="datePublished">2019-06-22</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/操作系统/">操作系统</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      存储管理
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="存储管理"><a href="#存储管理" class="headerlink" title="存储管理"></a>存储管理</h2><ul>
<li>存储管理是操作系统的重要组成部分，负责管理计算机系统的内存储器</li>
<li>由于任何程序和数据都必须占用内存空间才能得以执行和处理，因此存储管理的优劣直接影响系统的性能</li>
</ul>
<h2 id="存储器"><a href="#存储器" class="headerlink" title="存储器"></a>存储器</h2><ul>
<li><p>存储器的层次</p>
<ul>
<li>目前计算机系统采用层次结构的存储系统。        </li>
<li>内存储器用于保护进程运行时的数据和程序</li>
<li>由于内存储器的访问速度远低于CPU执行指令的速度，为缓和这一矛盾，引入了寄存器和高速缓存。</li>
<li>为扩充内存储器的存储空间 ，在磁盘上建立磁盘缓存，操作系统自动实现内存储器和磁盘缓存间的程序和数据的调进调出，从而面向用户提供比实际内存容量大的多的存储空间</li>
<li><font color="green">寄存器、高速缓存、内存储器、磁盘缓存属于操作系统存储管理范畴，掉电后所存储的信息不复存在。</font></li>
<li>固定磁盘和可移动介质属于设备管理的对象，所存储的信息将被持久保存。</li>
</ul>
</li>
<li><p>地址转换 </p>
<ol>
<li><p>程序的编译、链接、装入</p>
<ul>
<li>源程序是不能直接执行的，源程序要经过编译、链接、装入这三个阶段处理后才能装入内存运行。</li>
<li>编译：将源程序翻译成等价的若干目标代码（目标模块）</li>
<li>链接：把多个目标模块链接到一起，形成一个完整的可重定位目标程序（装载代码模块 ）。</li>
<li>装入：将装载代码模块装入系统分配的内存区。</li>
</ul>
</li>
<li><p>地址转换</p>
<ul>
<li><p>目标程序的逻辑结构</p>
<ul>
<li>逻辑地址：目标程序使用的地址为逻辑地址，也称<font color="green">程序地址、虚地址</font></li>
<li>逻辑地址空间：逻辑地址的集合，它的编址总是从0开始，可是一维的，也可是二维的。</li>
</ul>
</li>
<li><p>内存的物理组织</p>
<ul>
<li>物理地址：把内存分为若干存储单元 ，每单元8bit，并给每个单元一个编号，这个编号为物理地址</li>
<li>物理地址空间：物理地址集合，为一维空间 </li>
</ul>
</li>
<li><p>地址转换</p>
<ul>
<li><p>将<font color="green">程序使用的逻辑地址变换成内存中的物理地址</font>的过程 ，也称地址重定位、地址映射 。</p>
</li>
<li><p>两种方式</p>
<ul>
<li><p>静态地址重定位</p>
<ul>
<li>目标程序被<font color="green">装入内存时</font>完成程序的逻辑地址到内存物理地址的转换。</li>
<li><font color="red">物理地址=装入内存首地址+逻辑地址</font></li>
<li>优点：不需要硬件支持，易于实现</li>
<li>缺点 ：程序必须占用连续的内存空间；一旦程序装入后不能移动位置。（已不使用 ）</li>
</ul>
</li>
<li><p>动态地址重定位</p>
<ul>
<li><p>目标程序转入内存时，不能进行地址转换。程序内存的起始地址置于重定位寄存器中 ，<font color="green">程序执行过程中，每次访内存之前</font>，将要访问的逻辑地址加上重定位寄存器的值，从而转为物理地址</p>
</li>
<li><p>优点：</p>
<ul>
<li><p>允许程序在内存中移动 ，当程序从某个存储区移到另一个区域时，只需要修改 相应的寄存器BR的内容。</p>
</li>
<li><p>便于多个进程共享同一个程序的代码</p>
</li>
<li><p>一个程序不一定要求占用一个连续的内存空间</p>
</li>
</ul>
</li>
<li><p>代价</p>
<ul>
<li>需要硬件的支持</li>
<li>实现算法较为复杂</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ol>
</li>
<li><p>存储保护 </p>
<ul>
<li>实现多道程序之间互不干扰</li>
<li>界地址寄存器是被广泛使用的一种存储保护技术，机制比较简单，易于实现</li>
<li>实现方法主要两种：<font color="green">上下界保护，基址、限长寄存器保护 </font></li>
</ul>
<ol>
<li><p>上下界保护</p>
<p>下界寄存器：存放程序装入内存后的首地址</p>
<p>上界寄存器：存放程序装入内存后的末地址</p>
<p>判别式：（下界寄存器）≤物理地址 &lt;（上界寄存器）</p>
</li>
<li><p>基址、限长寄存器保护</p>
<p>基址寄存器：存放程序的起始地址</p>
<p>限长寄存器：程序的长度（逻辑地址）</p>
<p>判别式:0 ≤逻辑地址〈(限长寄存器)</p>
</li>
</ol>
<ul>
<li>区别：<ul>
<li>寄存器的设置不同</li>
<li>判别式中用的判别条件不同<ul>
<li>上下界寄存器保护法使用的是物理地址</li>
<li>基址、限长寄存器保护法使用的是程序的逻辑地址</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>存储管理的功能</p>
<ul>
<li>地址转换</li>
<li>存储保护</li>
<li>内存分配与回收<ul>
<li>按照一定的算法把某一空闲的内存区分配给进程，进程终止后回首内存区</li>
</ul>
</li>
<li><font color="red">存储扩充</font><ul>
<li>向用户提供一种不受物理存储器大小和结构限制的用户编程时使用的存储器，<font color="green">称为虚拟存储器</font></li>
<li><font color="green">现代计算机操作系统都采用了虚拟存储技术,使得用户编程序时不需要考虑物理内存的结构和容量,极大地方便了用户。</font></li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="连续存储空间管理"><a href="#连续存储空间管理" class="headerlink" title="连续存储空间管理"></a>连续存储空间管理</h2><ul>
<li>在早期的操作系统中，内存分配广泛采用连续分配方式</li>
<li>连续分配方式——为一个用户程序分配一个连续的内存空间</li>
</ul>
<ol>
<li><p>单一连续分配（单个分区）</p>
<ul>
<li><p>最简单的存储管理方式，用于多道程序设计技术之前</p>
</li>
<li><p>内存分为系统区和用户区，系统区给操作系统。用户区作为连续分区分配给一个作业</p>
</li>
<li><p>评价</p>
<ul>
<li><p>优点：方法简单，易于实现 </p>
</li>
<li><p>缺点：仅适用于单道程序，只能用于单用户单任务的操作系统</p>
<p>​            系统资源利用率低</p>
<p><font color="red">引入分区管理技术</font>：</p>
<ul>
<li><p>分区存储管理是满足多道程序设计的最简单的</p>
<p> 一种存储管理方法,它允许多个用户程序同时</p>
<p>存在系统内存中,即共享内存空间。</p>
</li>
<li><p>按分区划分方式可分为固定分区和可变分区。</p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>固定分区存储管理</p>
<ol>
<li><p>基本思想</p>
<p>把内存的用户区预先划分成多个分区,每个分区<br>大小可以相同,也可以不同。(<font color="green">分区的划分由计算机<br>的操作员或者由操作系统给出,并给出</font>内存分配表)<br><font color="green">分区个数固定,分区的大小固定。</font><br>一个分区中可装入一个作业,作业执行过程中不<br>会改变存放区域。</p>
</li>
<li><p>内存分配表</p>
<p>为了说明各分区的分配和使用情况,需设置“内<br>存分配表”,记录各分区及其使用情况。<br><font color="green">内存分配表内容:分区号,分区的起始地址,长度,占用标志。</font></p>
</li>
<li><p>内存空间分配</p>
<p>内存分配程序检索内存分配表,从中找到还未<br>分配且大小满足要求的分区,则将此分区分配给该作<br>业。若没找到满足条件的分区,则拒绝为该作业分配<br>内存。</p>
</li>
<li><p>性能分析</p>
<ul>
<li>在作业大小和出现频率已知的情况下，固定分区合适 。内存使用效率较高。</li>
<li>但是若作业的大小和出现频率不知道时，会造成分区的大小和作业大小相差太远，造成了存储空间的浪费 ，从而影响了整个系统的效率。</li>
<li>缺点：碎片问题，内存利用率低。</li>
</ul>
</li>
</ol>
</li>
<li><p>可变分区存储管理（动态分区）</p>
<ol>
<li><p>基本思想</p>
<p>内存不是预先划分好的,而是在系统运行的过程<br>中建立分区.当作业装入内存时,根据作业所需要的<br>内存容量查看是否有足够的内存空间,若有则按需要<br>分割一个分区给该作业;否则令该作业等待.<br><font color="green">分区长度不固定,分区个数不固定.</font></p>
<p><font color="green">这种存储管理的方法克服了固定分区严重浪费内存的问题,提高了内存资源的利用率。</font></p>
</li>
<li><p>实现可变分区需要的数据结构</p>
<ul>
<li>在可变分区存储管理中,要有相应的数据结构来登<br>记空闲区信息,它包括空闲区的大小和位置。</li>
<li>不同系统根据设计要求采用不同的结构。常用的有<br>表结构和链结构。</li>
<li>系统还要设置了等待分区队列,当系统中无空闲区<br>或无满足要求的空闲区时,则把申请者送入等待队<br>列中,等待别的进程释放内存之后再唤醒队列中的<br>进程。</li>
</ul>
</li>
<li><p>分区分配算法</p>
<ul>
<li><p>空闲区表(链)中的空闲区可按一定规则排列,<br>例如按空闲区大小的升序(降序)排列;按空<br>闲区地址升序(降序)组织。</p>
</li>
<li><p>根据空闲区表(链)排列方法不同,对应不同<br>的分配算法,常用的可变分区分配算法有最先<br>适应算法,下次适应分配算法,最优适应算法、<br>最坏适应算法等。</p>
</li>
</ul>
<ol>
<li><p>最先适应算法</p>
<ul>
<li>空闲区按地址从小到大的次序排列 </li>
<li>优点：有利于大作业的装入</li>
<li>缺点：在低地址部分，集中了许多非常小的空闲区（碎片），降低了内存的利用率</li>
</ul>
</li>
<li><p>下次适应分配算法</p>
<ul>
<li>最先适应算法的变种</li>
<li>总是从空闲区上次扫描结束处查找空闲区表（链），知道找到第一个满足的，分割一部分给作业，其余仍为空闲区</li>
</ul>
</li>
<li><p>最优适应算法</p>
<ul>
<li>空闲区按照容量递增的次序排列</li>
<li>优点：<ul>
<li>选中的空闲区是满足容量要求的最小空闲区，不会毁掉大空闲区</li>
</ul>
</li>
<li>缺点：<ul>
<li>空闲区的大小一般与申请大小不相等。随着时间推移，系统中的小空闲区越来越多 ，从而造成了存储空间的浪费。</li>
</ul>
</li>
</ul>
</li>
<li><p>最坏适应算法</p>
<p><font color="green">为了克服最佳适应算法把空闲区切割得太小的缺点,人们<br>提出了一种最坏适应算法,即每次分配时,总是将最大的空闲<br>区切去一部分分配给请求者,剩余的部分仍是一个较大的空闲<br>区。避免了空闲区越分越小的问题。</font></p>
<ul>
<li>要求空闲区按照容量递减的顺序排列</li>
<li>分析：<ul>
<li>当程序装入内存中最大的空闲区后，剩下的空闲区还可能相当大，还能装下较大的程序。</li>
<li>另一方面每次只做一次查询工作，查找效率高</li>
</ul>
</li>
</ul>
</li>
</ol>
</li>
<li><p>可变分区的回收</p>
<p>​        当某个进程释放某存储区时,系统首先检查释放区是否<br>与系统中的空闲区相邻,若相邻则把释放区合并到相邻的空<br>闲区中去,否则把释放区作为一个空闲区插入到空闲区表的<br>适当位置。</p>
<ul>
<li>释放区与前空闲区相邻<ul>
<li>将释放区与前空闲区合并为一个空闲区。其首址仍为前空闲区首址,大小为<br>释放区大小与空闲区大小之和。</li>
</ul>
</li>
<li>释放区与后空闲区相邻<ul>
<li>则把释放区合并到后空闲,首地址为释放区首地址,大小为二者大小之和。</li>
</ul>
</li>
<li>释放区与前后两个空闲区相邻<ul>
<li>将这三个区合为一个空闲区,其首址为前空闲区首址,大小为这三个<br>区大小之和,<font color="green">并取消原后空闲区表目。</font></li>
</ul>
</li>
<li>释放区不与任何空闲区相邻<ul>
<li>将释放区作为一个空闲区,将其大小和首址插入到空闲区表的适当位置</li>
</ul>
</li>
</ul>
</li>
<li><p>可变分区存储管理分析</p>
<p>优点：</p>
<ol>
<li>有助于多道程序设计</li>
<li>不需要多硬件，仅需界地址寄存器用于存储保护 </li>
<li>所采用算法都简单，易于实现</li>
</ol>
<p>缺点：</p>
<ol>
<li><p>碎片问题</p>
<p>由于空闲区的大小与申请内存的大小相等的情况是很少<br>的,绝大多数情况是从一个空闲区中切去一块,剩下的部分<br>作为一个空闲区仍留在空闲区表中,随着时间的推移,空闲<br>区的发展趋势是越来越小,直至不能满足任何用户要求。<br>这种不能被任何用户使用的极小的空闲区称为碎片。碎<br>片的出现造成了存储空间的浪费。</p>
</li>
<li><p>分区大小受到内存容量限制，无法扩充容量</p>
</li>
</ol>
</li>
</ol>
</li>
<li><p>可重定位分区存储管理</p>
<ul>
<li>解决碎片问题的一种简单方法是采用可重定位分区分配</li>
</ul>
<ol>
<li><p>基本思想</p>
<p>将内存中的作业进行移动,使它们连接在一起,<br>把原来分散的多个小分区拼接成一个大的空闲区.<br>这个过程称为<font color="red">”紧凑”或”移动”.</font><br><font color="red">需解决的问题:每次”紧凑”后,程序或数据装<br>入的物理地址变化,采用动态重定位.</font></p>
</li>
<li><p>动态重定位分区分配算法</p>
<p>与可变分区分配算法基本相同，差别在找不到足够大的空闲分区时进行“紧凑”。</p>
</li>
<li><p>分区分配方案评价</p>
<ul>
<li><p>优点：</p>
<p>1.实现了内存共享,有助于多道程序设计,提高了系统资源的利用<br>率;<br>内存利用率:可重定位分区分配&gt;可变分区分配&gt;固定分区分配<br>2.与后面所介绍的存储管理方式相比,实现分区分配所使用的表<br>格,占用的存储空间较少,算法也相对简单;<br>3.实现存储保护的措施也较简单。</p>
</li>
<li><p>缺点：</p>
<p>1.内存仍不能充分利用,除了可重定位分区法外,都存在碎片问题.<br>2.采用”紧凑”方法,虽解决了碎片问题,但系统开销太大.<br>3.不能实现对内存的扩充.因此作业大小受到内存可用空间限制.</p>
</li>
</ul>
</li>
</ol>
</li>
<li><p>覆盖技术和对换技术</p>
<ol>
<li>覆盖技术主要在早期操作中</li>
<li>对换技术被广泛用于小型分时系统中，交换技术发展导致了虚存技术出现</li>
</ol>
</li>
</ol>
<h2 id="分页存储管理"><a href="#分页存储管理" class="headerlink" title="分页存储管理"></a>分页存储管理</h2><ul>
<li>连续分配方式：单一连续分配-&gt;固定分区-&gt;可变分区</li>
<li>离散分配方式：<ul>
<li>分页</li>
<li>分段</li>
<li>段页式</li>
</ul>
</li>
</ul>
<ol>
<li><p>分页</p>
<ol>
<li>基本原理<ol>
<li>逻辑地址结构</li>
<li>物理块</li>
<li>物理地址结构</li>
<li>分页存储管理基本原理</li>
<li>页表</li>
</ol>
</li>
<li>地址转换<ul>
<li>块表 </li>
</ul>
</li>
<li>内存的有效访问时间</li>
<li>地址转换计算</li>
</ol>
</li>
<li><p>分段</p>
<ol>
<li><p>问题提出</p>
</li>
<li><p>基本原理</p>
<ol>
<li>分段</li>
<li>逻辑地址结构</li>
<li>分段存储管理基本原理</li>
<li>段表</li>
</ol>
</li>
<li><p>地址转换</p>
<ol>
<li>分析</li>
</ol>
<ul>
<li>块表</li>
</ul>
</li>
<li><p>段的共享</p>
</li>
<li><p>分段和分页比较 </p>
</li>
</ol>
</li>
<li><p>段页式存储管理</p>
<ol>
<li>基本原理<ol>
<li>用户程序划分</li>
<li>逻辑地址</li>
<li>内存划分</li>
<li>内存分配 </li>
<li>页表</li>
<li>段表</li>
</ol>
</li>
</ol>
</li>
</ol>
<h2 id="虚拟存储管理"><a href="#虚拟存储管理" class="headerlink" title="虚拟存储管理"></a>虚拟存储管理</h2>
      
    </div>
    <footer class="article-footer">
      
        <a data-url="http://yoursite.com/2019/06/22/存储管理/" data-id="cjx7eywr100021fdbagi06rye" class="article-share-link" data-share="baidu" data-title="存储管理">Share</a>
      

      

      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/操作系统/">操作系统</a></li></ul>

    </footer>
  </div>
  
    
<nav id="article-nav">
  
  
    <a href="/2019/06/09/hello-world/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title">Hello World</div>
    </a>
  
</nav>

  
</article>

</section>
      
      <aside id="sidebar">
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Categories</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/操作系统/">操作系统</a><span class="category-list-count">1</span></li></ul>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/操作系统/">操作系统</a><span class="tag-list-count">1</span></li></ul>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/操作系统/" style="font-size: 10px;">操作系统</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/06/">June 2019</a><span class="archive-list-count">2</span></li></ul>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2019/06/22/存储管理/">存储管理</a>
          </li>
        
          <li>
            <a href="/2019/06/09/hello-world/">Hello World</a>
          </li>
        
      </ul>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Links</h3>
    <div class="widget">
      <ul>
        
      </ul>
    </div>
  </div>

  
</aside>
      
    </div>
    <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2019 John Doe<br>
      Powered by <a href="//hexo.io/" target="_blank">Hexo</a>
      .
      Theme by <a href="https://github.com/xiangming/landscape-plus" target="_blank">Landscape-plus</a>
    </div>
  </div>
</footer>
  </div>
  <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
  <!-- totop start -->
<div id="totop">
<a title="totop"><img src="/img/scrollup.png"></a>
</div>

<!-- totop end -->


<!-- 百度分享 start -->

<div id="article-share-box" class="article-share-box">
  <div id="bdshare" class="bdsharebuttonbox article-share-links">
    <a class="article-share-weibo" data-cmd="tsina" title="分享到新浪微博"></a>
    <a class="article-share-weixin" data-cmd="weixin" title="分享到微信"></a>
    <a class="article-share-qq" data-cmd="sqq" title="分享到QQ"></a>
    <a class="article-share-renren" data-cmd="renren" title="分享到人人网"></a>
    <a class="article-share-more" data-cmd="more" title="更多"></a>
  </div>
</div>
<script>
  function SetShareData(cmd, config) {
    if (shareDataTitle && shareDataUrl) {
      config.bdText = shareDataTitle;
      config.bdUrl = shareDataUrl;
    }
    return config;
  }
  window._bd_share_config={
    "common":{onBeforeClick: SetShareData},
    "share":{"bdCustomStyle":"/css/bdshare.css"}
  };
  with(document)0[(getElementsByTagName('head')[0]||body).appendChild(createElement('script')).src='//bdimg.share.baidu.com/static/api/js/share.js?cdnversion='+~(-new Date()/36e5)];
</script>

<!-- 百度分享 end -->

<script src="//cdnjs.cloudflare.com/ajax/libs/jquery/1.11.1/jquery.min.js"></script>




<! -- mathjax config similar to math.stackexchange -->

<script type="text/x-mathjax-config">
MathJax.Hub.Config({
tex2jax: {
          inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
                processEscapes: true
                    
}
  
        });
</script>

<script type="text/x-mathjax-config">
MathJax.Hub.Config({
tex2jax: {
            skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
                  
}
    
        });
</script>

<script type="text/x-mathjax-config">
MathJax.Hub.Queue(function() {
            var all = MathJax.Hub.getAllJax(), i;
            for(i=0; i < all.length; i += 1) {
                            all[i].SourceElement().parentNode.className += ' has-jax';
                                    
            }
                
        });
</script>

<script type="text/javascript" src="//cdn.bootcss.com/mathjax/2.5.3/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>


<script src="/js/script.js"></script>

</div>
</body>
</html>
